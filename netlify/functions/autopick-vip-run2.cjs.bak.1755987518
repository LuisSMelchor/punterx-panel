
'use strict';
exports._impl = async (event, context) => {
  try {
    const qs = (event && event.queryStringParameters) || {};

    // smoke opcional
    if (qs.smoke === '1') {
      try {
  const _r = (typeof resumen!=='undefined' && resumen) ? JSON.stringify(resumen) : null;
  if (_r) console.log('[run2] resumen', _r);
  if (resumen && resumen.debugLog) {
    const chunk = String(resumen.debugLog).slice(0, 12000);
    console.log('[run2] detalle', chunk);
  }
} catch(e){ console.log('[run2] log error', e && e.message); }
try { console.log('[run2] end ok', { ts: new Date().toISOString() }); } catch {}
  return {
        statusCode: 200,
        headers: { 'content-type':'application/json' },
        body: JSON.stringify({ ok:true, stage:'run2.smoke', debug: qs.debug === '1' })
      };
    }

    // Cargar la implementación real
// __LAZY__ mod require comentado
    if (!mod || typeof mod.handler !== 'function') {
      return { statusCode:200, headers:{'content-type':'application/json'},
        body: JSON.stringify({ ok:false, stage:'run2.wrapper', error:'handler no encontrado' }) };
    }

    // Inyecta AUTH si falta (para scheduled)
    const expected = (process.env.AUTH_CODE || '').trim();
    const inHeaders = (event && event.headers) ? { ...event.headers } : {};
    if (expected && !inHeaders['x-auth-code'] && !inHeaders['x-auth']) {
      inHeaders['x-auth-code'] = expected;
    }

    // Fuerza manual=1 (misma ruta de logs que usas) y preserva debug
    const newQs = { manual:'1' };
    if (qs.debug === '1') newQs.debug = '1';

    const newEvent = { ...(event||{}), headers: inHeaders, queryStringParameters: newQs };

    // Delegar
    return await mod.handler(newEvent, context);

  } catch (e) {
    try { console.error('[run2] fail', { ts: new Date().toISOString(), err: (e && e.stack) || (e && e.message) || String(e) }); } catch {}
    return { statusCode:200, headers:{'content-type':'application/json'},
      body: JSON.stringify({ ok:false, stage:'run2.catch', error:String(e && (e.message||e)), stack: e && e.stack ? String(e.stack): null }) };
  }
};

/* ---- wrapper robusto (no añade dependencias) ---- */
exports._impl = async (event, context) => {
  try {
    // ping rápido para verificar que el archivo carga
    const qs = (event && event.queryStringParameters) || {};
    if (qs && qs.ping === '1') {
      return { statusCode: 200, headers:{'content-type':'application/json'},
               body: JSON.stringify({ ok:true, ping:'autopick-vip-run2 (pong)' }) };
    }
    return await exports._impl(event, context);
  } catch (e) {
    // si algo truena, devolvemos JSON (y no 500 con texto)
    console.error('[run2][fatal]', e && e.stack || e);
    return { statusCode: 200, headers:{'content-type':'application/json'},
             body: JSON.stringify({ ok:false, fatal:true, error: String(e && e.message || e) }) };
  }
};

/* ---- wrapper robusto (no añade dependencias) ---- */
exports.handler = async (event, context) => {
  try {
    // ping rápido para verificar que el archivo carga
    const qs = (event && event.queryStringParameters) || {};
    if (qs && qs.ping === '1') {
      return { statusCode: 200, headers:{'content-type':'application/json'},
               body: JSON.stringify({ ok:true, ping:'autopick-vip-run2 (pong)' }) };
    }
    return await exports._impl(event, context);
  } catch (e) {
    // si algo truena, devolvemos JSON (y no 500 con texto)
    console.error('[run2][fatal]', e && e.stack || e);
    return { statusCode: 200, headers:{'content-type':'application/json'},
             body: JSON.stringify({ ok:false, fatal:true, error: String(e && e.message || e) }) };
  }
};

/* === run2: wrapper seguro (idempotente) === */
if (!module.exports.__run2Wrapped) {
  module.exports.__run2Wrapped = true;
  const __orig = module.exports.handler;
  const __json = (code, obj) => ({
    statusCode: code,
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(obj)
  });

  module.exports.handler = async (event, context) => {
    try {
      const qs = (event && event.queryStringParameters) || {};
      // ping: evita ejecutar nada más
      if (qs && qs.ping === '1') {
        return __json(200, { ok: true, ping: 'autopick-vip-run2 (pong)' });
      }

      if (typeof __orig !== 'function') {
        console.error('[run2] handler original no definido');
        return __json(200, { ok: false, fatal: true, error: 'handler original no definido' });
      }

      const res = await __orig(event, context);

      // fuerza JSON para que NUNCA veas "Internal Error" en texto plano
      if (!res || typeof res.statusCode !== 'number') {
        return __json(200, { ok: false, error: 'Respuesta inválida del handler' });
      }
      const h = res.headers || {};
      if (!(h['content-type'] || '').toLowerCase().includes('application/json')) {
        res.headers = { ...h, 'content-type': 'application/json' };
        if (res.body && typeof res.body !== 'string') res.body = JSON.stringify(res.body);
        if (!res.body && res.statusCode === 200) res.body = JSON.stringify({ ok: true });
      }
      return res;
    } catch (e) {
      console.error('[run2] fatal:', e && e.stack || e);
      return __json(200, { ok: false, fatal: true, error: String((e && e.message) || e) });
    }
  };
}


/* === run2: handler perezoso y seguro (idempotente) === */
if (!module.exports.__lazyRun2) {
  module.exports.__lazyRun2 = true;
  const __prev = module.exports.handler;
  const __json = (code, obj) => ({ statusCode: code, headers: { 'content-type': 'application/json' }, body: JSON.stringify(obj) });

  module.exports.handler = async (event, context) => {
    try {
      const qs = (event && event.queryStringParameters) || {};
      if (qs && qs.ping === '1') return __json(200, { ok: true, ping: 'autopick-vip-run2 (pong)' });

      if (typeof __prev === 'function') {
        try {
          const r = await __prev(event, context);
          if (r && typeof r.statusCode === 'number') return r;
        } catch (e) {
          console.error('[run2] __prev handler error:', e && e.stack || e);
        }
      }

      let impl;
      try { impl = require('./autopick-vip-nuevo-impl.cjs'); }
      catch (e) {
        console.error('[run2] require impl error:', e && e.stack || e);
        return __json(200, { ok: false, fatal: true, stage: 'require impl', error: String((e && e.message) || e) });
      }

      const fn = (impl && (impl.handler || impl.default || impl));
      if (typeof fn !== 'function') return __json(200, { ok: false, fatal: true, stage: 'resolve impl', error: 'impl no expone función' });

      try {
        const out = await fn(event, context);
        if (!out || typeof out.statusCode !== 'number') return __json(200, { ok: false, error: 'respuesta inválida del impl', raw: out });
        return out;
      } catch (e) {
        console.error('[run2] impl runtime error:', e && e.stack || e);
        return __json(200, { ok: false, fatal: true, stage: 'impl runtime', error: String((e && e.message) || e) });
      }
    } catch (e) {
      console.error('[run2] wrapper fatal:', e && e.stack || e);
      return __json(200, { ok: false, fatal: true, stage: 'wrapper', error: String((e && e.message) || e) });
    }
  };
}
