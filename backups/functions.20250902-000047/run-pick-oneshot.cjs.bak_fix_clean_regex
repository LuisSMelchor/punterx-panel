'use strict';
;/* === AI_JSON sanity helper (seguro, idempotente) === */
global.__applyAISanity = function(){
  try{
    if (typeof global.ai_json === 'string') {
      try { global.ai_json = JSON.parse(global.ai_json); } catch { global.ai_json = {}; }
    }
    if (!global.ai_json || typeof global.ai_json !== 'object') global.ai_json = {};
    global.AI_SAFE = {
      resumen: global.ai_json.resumen || "",
      ev_estimado: Number(global.ai_json.ev_estimado || 0),
      probabilidad: Number(global.ai_json.probabilidad || 0),
      ap_sugerida: global.ai_json.ap_sugerida || {}
    };
    try { console.log('[AI.sanity.ok]', Object.keys(global.AI_SAFE)); } catch {}
  } catch(e){
    try { console.warn('[AI.sanity.fail]', e && e.message || e); } catch {}
    global.AI_SAFE = {};
  }
};
/* === /AI_JSON sanity helper === */

;
/* === finalize helper: usa AI_SAFE y limpia reason === */
global.normalizeFinal = function(resp){
  try {
    const hasAI = !!(global.AI_SAFE && Object.keys(global.AI_SAFE).length);
    resp = resp || {};
    if (hasAI) {
      resp.payload = resp.payload || {};
      resp.payload.ai_json = resp.payload.ai_json || global.AI_SAFE;
      resp.meta = Object.assign({}, resp.meta, { ai_ok: true });
      if (resp.reason === 'invalid-ai-json') delete resp.reason;
    } else {
      resp.meta = Object.assign({}, resp.meta, { ai_ok: false });
    }
  } catch(_) {}
  return resp;
};
/* === /finalize helper === */

console.log("[BOOT]", new Date().toISOString());

/* global helper visible para m√≥dulos de enrich */
global.setEnrichStatus = (p, status) => {
  if (p && typeof p === 'object') {
    p.meta = p.meta || {};
    p.meta.enrich_status = status;
  }
  return p;
};

var send_report, markets, markets_top3, ai_json, ev_estimado; // global safe decls
// ensureEnrichDefaults helper
const { ensureEnrichDefaults } = require('./_utils/enrich-defaults.cjs');
const { oneShotPayload, composeOneShotPrompt, ensureMarketsWithOddsAPI } = require('./_lib/enrich.cjs');
const { resolveTeamsAndLeague } = require('./_lib/af-resolver.cjs');
const { callOpenAIOnce } = require('./_lib/ai.cjs');
let sendTelegramText = null;
try {
  // opcional: solo si existe el helper
  ({ sendTelegramText } = require('./_lib/tx.cjs'));
} catch {}

function safeExtractFirstJson(text='') {
  try { return JSON.parse(text); } catch {}
  const s = String(text);
  let depth = 0, start = -1;
  for (let i=0;i<s.length;i++){
    const ch = s[i];
    if (ch === '{') { if (depth===0) start=i; depth++; }
    else if (ch === '}') {
      depth--;
      if (depth===0 && start>=0) {
        const cand = s.slice(start,i+1);
        try { return JSON.parse(cand); } catch {}
        start = -1;
      }
    }
  }
  return null;
}

function isFiniteNum(n){ return typeof n==='number' && Number.isFinite(n); }

// EV% = ((prob/100) * odds - 1) * 100
function calcEV(probPct, odds) {
  if (!isFiniteNum(probPct) || !isFiniteNum(odds) || odds <= 1) return null;
  const ev = ((probPct/100)*odds - 1) * 100;
  return Math.round(ev * 10) / 10; // 1 decimal
}

function minutesFromNow(iso) {
  const t = new Date(iso).getTime() - Date.now();
  return Math.max(0, Math.round(t/60000));
}
function fmtComienzaEn(iso) {
  const m = minutesFromNow(iso);
  return `Comienza en ${m} minutos aprox`;
}

// Normaliza string: min√∫sculas, sin tildes, solo [a-z0-9 ]
function _normStr(x) {
  return String(x||'')
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/[^a-z0-9]+/g,' ')
    .trim();
}

// Mapea nombres ES/variantes ‚Üí claves oddsapi
function marketKeyFromName(name) {
  const n = _normStr(name);
  if (!n) return null;

  // H2H / Resultado Final / 1X2 / Moneyline
  if (/(^| )resultado( final)?($| )|(^| )1x2($| )|(^| )moneyline($| )|(^| )ganador($| )|(^| )h ?2 ?h($| )/.test(n)) return 'h2h';

  // Totales / M√°s-Menos / Over-Under / Goles
  if (/(^| )(total(es)?|mas\/?menos|mas menos|over|under|o\/u|goles)($| )/.test(n)) return 'totals';

  // Ambos marcan / BTTS
  if (/(^| )(ambos equipos marcan|ambos marcan|btts)($| )/.test(n)) return 'btts';

  return null;
}

function top3FromMarkets(markets, chosen, apS) {
  if (!markets || typeof markets !== "object") return null;

  // 1) Resolver clave de mercado: chosen (mapeado) -> h2h -> totals -> spreads -> primer key
  let mkey = null;
  if (chosen) {
    try {
      const cand = marketKeyFromName(chosen);
      if (cand && Array.isArray(markets[cand]) && markets[cand].length) mkey = cand;
    } catch {}
  }
  if (!mkey) {
    for (const k of ["h2h","totals","spreads"]) {
      if (Array.isArray(markets[k]) && markets[k].length) { mkey = k; break; }
    }
  }
  if (!mkey) {
    const keys = Object.keys(markets||{});
    if (keys.length && Array.isArray(markets[keys[0]]) && markets[keys[0]].length) mkey = keys[0];
  }
  if (!mkey) return null;

  // 2) Copia y, si hay labels + selecci√≥n IA, prioriza outcomes que mach√©an la selecci√≥n
  let arr = (markets[mkey] || []).slice();
  const norm = (x) => String(x||"").toLowerCase().replace(/[^a-z0-9]+/g," ").trim();
  const sel = apS && apS.seleccion ? norm(apS.seleccion) : null;
  if (sel && arr.length && Object.prototype.hasOwnProperty.call(arr[0]||{}, "label")) {
    const withSel = arr.filter(x => sel.includes(norm(x.label)));
    const withoutSel = arr.filter(x => !sel.includes(norm(x.label)));
    arr = withSel.concat(withoutSel);
  }

  // 3) Ordenar por mejor cuota y tomar Top 3
  arr = arr.sort((a,b)=>(Number(b.price)||0)-(Number(a.price)||0)).slice(0,3);
  if (!arr.length) return null;

  const lines = arr.map((x,i)=>{
    const label = x && x.label ? " (" + x.label + ")" : "";
    return (i+1) + ". " + (x.book||"book") + " ‚Äî " + (x.price||"-") + label;
  }).join("\n");
  return lines;
}

function classifyByEV(ev) {
  if (!isFiniteNum(ev)) return 'N/A';
  if (ev >= 40) return 'Ultra Elite';
  if (ev >= 30) return '√âlite Mundial';
  if (ev >= 20) return 'Avanzado';
  if (ev >= 15) return 'Competitivo';
  if (ev >= 10) return 'Informativo';
  return 'Descartado';
}

function buildMessages({liga, pais, home, away, kickoff_iso, ev, prob, nivel, markets, ap_sugerida, apuestas_extra, includeBookiesInFree=false}) {
  const ligaStr = pais ? `${liga} (${pais})` : liga;
  const horaStr = fmtComienzaEn(kickoff_iso);
  const bookies = top3FromMarkets(markets, ap_sugerida?.mercado, ap_sugerida);

  // Frase IA breve
  const sel = ap_sugerida?.seleccion ? String(ap_sugerida.seleccion) : '';
  const cuo = (ap_sugerida?.cuota != null) ? `${ap_sugerida.cuota}` : '‚Äî';
  const evStrBrief = (Number.isFinite(ev) ? `${ev}%` : '‚Äî');
  const probStrBrief = (Number.isFinite(prob) ? `${prob}%` : '‚Äî');
  const iaTagline = sel ? `${sel} @ ${cuo} | EV ${evStrBrief} | P(${probStrBrief})` : 'Valor detectado por IA';

  const datosBasicos =
`Liga: ${ligaStr}
Partido: ${home} vs ${away}
Hora estimada: ${horaStr}`;

  const apuestaSug = ap_sugerida
    ? `Apuesta sugerida: ${ap_sugerida.mercado} ‚Äî ${ap_sugerida.seleccion} (cuota ${ap_sugerida.cuota ?? '‚Äî'})`
    : 'Apuesta sugerida: ‚Äî';

  const extras = Array.isArray(apuestas_extra) && apuestas_extra.length
    ? apuestas_extra.map(x=>`‚Ä¢ ${x.mercado}: ${x.seleccion} (cuota ${x.cuota ?? '‚Äî'})`).join("\n")
    : '‚Äî';

  const probStr = Number.isFinite(prob) ? `${prob}%` : '‚Äî';
  const evStr = Number.isFinite(ev) ? `${ev}%` : '‚Äî';
  const bookiesStr = bookies ? `Top 3 bookies:
${bookies}` : '';

  const vipBookiesSection = bookies ? `Top 3 bookies:
${bookies}
` : '';
const bookiesStrFree = (includeBookiesInFree && bookies) ? bookiesStr : '';

  // Canal (Informativo)
  const canalHeader = 'üì° RADAR DE VALOR';
  const canalCta = 'üëâ √önete al grupo VIP y prueba 15 d√≠as gratis.';
  const canalMsg =
`${canalHeader}
${datosBasicos}

An√°lisis de los expertos (IA):
${iaTagline}

${bookiesStrFree}

${canalCta}`;

  // VIP (>=15%)
  const vipHeader = `üéØ PICK NIVEL: ${nivel}`;
  const vipDisclaimer = '‚ö†Ô∏è Apuesta con responsabilidad. Esto no es consejo financiero.';
  const vipMsg =
`${vipHeader}
${datosBasicos}

EV estimado: ${evStr}
Probabilidad estimada: ${probStr}

${apuestaSug}

Apuestas extra:
${extras}

Datos avanzados (IA):
- Diagn√≥stico IA en base a datos
- Tendencias y contexto del partido

${bookiesStr}

${vipDisclaimer}`;

    return { statusCode: 200, body: JSON.stringify(global.normalizeFinal ? global.normalizeFinal(payload) : payload) };
}

exports.handler = async (event) => {
  // ---- BODY PARSE (√∫nico punto de entrada) ----
  const __PARSE_BODY_SANITY__=true;
  let __body={};
  try{
    if(event && typeof event.body==='string' && event.body.trim().length){
      __body=JSON.parse(event.body);
    }else if(event && typeof event.body==='object' && event.body){
      __body=event.body;
    }
  }catch(e){ console.warn('[body.parse.fail]',e?.message||e); __body={}; }

  // Exponer variables esperadas por el resto del archivo (sin redeclarar con let)
  try{
    if(typeof evt==='undefined'){ global.evt=__body.evt||{}; } else { evt=__body.evt||evt||{}; }
    if(typeof ai_json==='undefined'){ global.ai_json=__body.ai_json; } else { ai_json=(__body.ai_json ?? ai_json); }
    if(typeof markets==='undefined'){ global.markets=__body.markets; } else { markets=(__body.markets ?? markets); }
    if(typeof markets_top3==='undefined'){ global.markets_top3=__body.markets_top3; } else { markets_top3=(__body.markets_top3 ?? markets_top3); }
  }catch(e){ console.warn('[body.expose.fail]',e?.message||e); }
  
// --- write-through de body -> globals (idempotente, tolera string/obj) ---
try {
  const __body = (typeof event?.body==='string') ? JSON.parse(event.body) : (event?.body||{});
  if (typeof global.evt === 'undefined') global.evt = {};
  if (typeof global.ai_json === 'undefined') global.ai_json = {};

  // evt_payload: objeto plano
  if (__body && typeof __body.evt === 'object') {
    global.evt = Object.assign({}, __body.evt);
  }

  // ai_json: soporta string JSON o objeto
  if (typeof __body.ai_json === 'string') {
    try { global.ai_json = JSON.parse(__body.ai_json); } catch {}
  } else if (__body && typeof __body.ai_json === 'object') {
    global.ai_json = Object.assign({}, __body.ai_json);
  }

  // snapshots inmutables (para pasar a otras funciones)
  global.EVT_SAFE = Object.freeze({ ...(global.evt||{}) });
  global.AI_SAFE  = Object.freeze({ ...(global.ai_json||{}) });

  console.log('[PARSE.ok]', { haveEvt:!!Object.keys(global.evt||{}).length, haveAI:!!Object.keys(global.ai_json||{}).length });
} catch(e) { console.warn('[PARSE.fail]', e?.message||e); }

// ----------------------------------------------

// ----------------------------------------------
  // >>> sanity after parse
  try {
    console.log('[EVT.after-parse]', evt && {home:evt.home, away:evt.away, league:evt.league, commence:evt.commence});
    console.log('[AI.after-parse]', (typeof ai_json==='string')?'(string json)':(ai_json && Object.keys(ai_json)));
  } catch(e) { console.warn('[sanity.log.fail]', e?.message||e); }
  // <<< sanity after parse
  ;global.__applyAISanity();
  // Snapshot expl√≠cito para usar en resolver
  const EVT_SAFE = (evt && typeof evt==='object') ? Object.freeze({...evt}) : Object.freeze({});

  // === EVT WRITE-LOCK (post-parse) ===
  try {
    if (evt && typeof evt==='object') {
      const __LOCK__ = Object.freeze({ ...evt });
      Object.defineProperty(global, 'evt', {
        configurable: false,
        get(){ return __LOCK__; },
        set(_){ /* ignore writes to evt */ }
});
      console.log('[EVT.locked]', {home:evt.home, away:evt.away, league:evt.league, commence:evt.commence});
    }
  } catch(e){ console.warn('[evt.lock.fail]', e?.message||e); }
  // === /EVT WRITE-LOCK ===

  // snapshot evt para evitar pisadas posteriores
  try { if (evt && typeof evt==='object' && (evt.home||evt.away||evt.league||evt.commence))
    global.__EVT_SNAPSHOT__ = JSON.stringify(evt);
  } catch(_) {}

  // ===== BODY INSPECT (debug) =====
  try{
    const ct=(event&&event.headers&&(event.headers['content-type']||event.headers['Content-Type']||'' )).split(';')[0];
    const rawLen=typeof event?.body==='string'?event.body.length:(event?.body? -1:0);
    console.log('[BODY] method=%s ct=%s rawLen=%s',event?.httpMethod,ct,rawLen);
    if(typeof event?.body==='string'){
      try{ const tmp=JSON.parse(event.body); console.log('[BODY.PARSED.keys]',Object.keys(tmp||{})); }
      catch(e){ console.warn('[BODY.parse.error]',e?.message||e); }
    } else {
      console.log('[BODY.type]',typeof event?.body);
    }
  }catch(e){ console.warn('[BODY.inspect.error]',e?.message||e); }
  // =================================

  // S1.2-TDZ: mensajes ruteo (declaraci√≥n √∫nica al inicio del handler)
  let message_free = null;
  let message_vip = null;
  try {
    const qs = event?.queryStringParameters || {};
    const evt_payload = {
      home: qs.home || '',
      away: qs.away || '',
      league: qs.league || '',
      commence: qs.commence || new Date(Date.now() + 60*60*1000).toISOString()
    };

    // Resolver (puede no encontrar IDs; enrich.cjs ya tiene fallback de odds por nombres)
    const match = await resolveTeamsAndLeague(EVT_SAFE, {});
    const fixture = {
      fixture_id: match?.fixture_id || null,
      kickoff: evt.commence,
      league_id: match?.league_id || null,
      league_name: match?.league_name || evt.league || null,
      country: match?.country || null,
      home_id: match?.home_id || null,
      away_id: match?.away_id || null
};

    let payload = await oneShotPayload({ evt, match, fixture });
            if (!payload || typeof payload !== 'object') payload = {};
    payload.meta = (payload.meta && typeof payload.meta === 'object') ? payload.meta : {};

  
  // __MARKETS_GUARD__: asegurar objeto markets aunque falle el enrich
  (function(){
    try {
      payload.markets = (payload && typeof payload.markets === "object" && payload.markets) ? payload.markets : {};
    } catch(_) { payload = payload || {}; payload.markets = {}; }
  })();
payload = ensureEnrichDefaults(payload, { optIn: (String(process.env.ODDS_ENRICH_ONESHOT) === "1") });
payload.meta = payload.meta || {};
// Ensure meta bag exists + annotate safe 'skipped' flags
    payload.meta = payload.meta || {};
    if (String(process.env.DISABLE_OPENAI) === '1') payload.meta.ai = payload.meta.ai || 'skipped';
    if (String(process.env.ODDS_ENRICH_ONESHOT) !== '1') payload.meta.enrich_attempt = payload.meta.enrich_attempt || 'skipped';
// Enriquecimiento OddsAPI (opt-in): telemetr√≠a m√≠nima + try/catch seguro
if (String(process.env.ODDS_ENRICH_ONESHOT) === '1') {
  payload.meta = { ...(payload.meta||{}), enrich_attempt: 'oddsapi:events' };
  try {
    payload = await ensureMarketsWithOddsAPI(payload, evt);
payload = setEnrichStatus(payload, "ok");

  } catch (e) {
    if (Number(process.env.DEBUG_TRACE) === 1) {
      console.log('[ENRICH] ensureMarketsWithOddsAPI error:', e?.message || String(e));
    }
    payload.meta = { ...(payload.meta||{}), enrich_status: 'error' };
  }
} else {
  payload.meta = { ...(payload.meta||{}), enrich_attempt: 'skipped' };
}
const prompt = composeOneShotPrompt(payload);
    const ai = await callOpenAIOnce({ prompt });

    if (!ai.ok) {
    };

      
      // --- safe guard: ap_sugerida ---
      const ap_sugerida = (
        (payload && payload.ai_json && payload.ai_json.ap_sugerida) ||
        (typeof global !== 'undefined' && global.AI_SAFE && global.AI_SAFE.ap_sugerida) ||
        (typeof ai_json !== 'undefined' && ai_json && ai_json.ap_sugerida) ||
        {}
      );
      let oddsToUse = isFiniteNum(Number(ap_sugerida?.cuota)) ? Number(ap_sugerida.cuota) : null;

      if (!isFiniteNum(oddsToUse) && ap_sugerida?.mercado && payload?.markets) {
    }

    const evOut = isFiniteNum(ev) ? ev : null;

    // Env√≠o autom√°tico a Telegram (si habilitado)
    send_report = { enabled: false };
const minVipEv = Number.isFinite(Number(process.env.MIN_VIP_EV)) ? Number(process.env.MIN_VIP_EV) : 15;
const sendToVip = (evOut != null && evOut >= minVipEv);
if (String(process.env.SEND_ENABLED) === '1' && typeof sendTelegramText === 'function') {
      const vipId = process.env.TG_VIP_CHAT_ID || null;
      const freeId = process.env.TG_FREE_CHAT_ID || null;
      send_report = { enabled:true, results: [] };

      if (sendToVip) {
  if (vipId && message_vip) {
    const r = await 
sendTelegramText({ chatId: vipId, text: vipMsg });
    send_report.results.push({ target: 'VIP', ok: r.ok, parts: r.parts, errors: r.errors });
  } else {
    send_report.missing_vip_id = (String(process.env.SEND_ENABLED)==='1') && !!message_vip  && !process.env.TG_VIP_CHAT_ID;
  }
} else {
  if (freeId && message_free) {
    const r = await sendTelegramText({ chatId: freeId, text: canalMsg });
    send_report.results.push({ target: 'FREE', ok: r.ok, parts: r.parts, errors: r.errors });
  } else {
    send_report.missing_free_id = (String(process.env.SEND_ENABLED)==='1') && !!message_free && !process.env.TG_FREE_CHAT_ID;
  }
}
    }

    message_vip = sendToVip ? vipMsg : null;
message_free = sendToVip ? null : canalMsg;

  // === FINAL_GATE_START ===
(() => {
  const vipMin = Number(process.env.MIN_VIP_EV || '15');

  // 0) EV robusto (acepta evOut, ev, ev_estimado %, ai_json.ev_estimado fracci√≥n)
  let evNum = 0;
  try {
    if (typeof evOut !== 'undefined') evNum = Number(evOut);
    else if (typeof ev !== 'undefined') evNum = Number(ev);
    else if (typeof ev_estimado !== 'undefined') evNum = Number(ev_estimado);
    else if (typeof ai_json !== 'undefined' && ai_json && ai_json.ev_estimado != null) {
      const v = Number(ai_json.ev_estimado);
      evNum = (v <= 1 ? v * 100 : v);
    }
  } catch (_) {}

  // 1) ¬øhay bookies?
  // hasOdds: verdadero si existe al menos un mercado con elementos
  const hasOdds = (() => {
    try {
      const src = (typeof markets !== 'undefined' && markets && typeof markets === 'object') ? markets
                : (typeof markets_top3 !== 'undefined' && markets_top3 && typeof markets_top3 === 'object') ? markets_top3
                : null;
      if (!src) return false;
      const keys = Object.keys(src);
      if (!keys.length) return false;
      for (const k of keys) {
        const v = src[k];
        if (Array.isArray(v) && v.length) return true;
      }
      return false;
    } catch { return false; }
  })();

  // 2) Determinar destino
  let target = 'none';
  if (!hasOdds) {
    // Sin odds: nunca VIP. FREE s√≥lo si nivel == Informativo.
    target = (nivel === 'Informativo') ? 'free' : 'none';
  } else {
    if (nivel === 'Informativo')      target = 'free';
    else if (evNum >= vipMin)         target = 'vip';
    else                              target = 'none';
  }

  // 3) Limpieza y FREE sin bookies
  const clean = (txt) => String(txt || '')
    .replace(/\s{3}/g, ' ')
').replace(/[ \t]+/g, '
    .trimEnd();
  const stripBookiesForFree = (txt) => {
    if (!txt) return txt;
    return txt
      .replace(/(?:+)?Top\s*3\s*bookies[\s\S]*$/i, '')
      .replace(/\s{3}/g, ' ')
').trimEnd();
  };

  // 4) Asignaci√≥n final (sin redeclarar)
  if (target === 'free') {
    message_free = clean(stripBookiesForFree(canalMsg));
    message_vip  = null;
  } else if (target === 'vip') {
    message_vip  = clean(vipMsg);
    message_free = null;
  } else {
    message_free = null;
    message_vip  = null;
  }
})();
 // === FINAL_GATE_END ===
    return { statusCode: 200, body: JSON.stringify(global.normalizeFinal ? global.normalizeFinal(payload) : payload) };

} catch(e) { try{ console.warn("[fix.try.tail]", e && (e.message||e)); } catch{} };

module.exports.marketKeyFromName = marketKeyFromName;

      };