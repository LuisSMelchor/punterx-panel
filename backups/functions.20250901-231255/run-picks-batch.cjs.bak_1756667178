'use strict';

const { ensureMarketsWithOddsAPI, oneShotPayload } = require('./_lib/enrich.cjs');

/** -----------------------------
 * Utilidades de muestreo/keys
 * ----------------------------*/
function marketSamples(markets = {}) {
  const out = {};
  for (const k of Object.keys(markets || {})) {
    const arr = markets[k];
    out[k] = Array.isArray(arr) ? arr.length : 0;
  }
  return out;
}
function uniq(arr){ return Array.from(new Set(arr||[])); }
function keyOfBook(x){ return (x && (x.bookmaker || x.source || 'n/a')); }
function booksCount(arr=[]) { return new Set((arr||[]).map(keyOfBook).filter(Boolean)).size; }

/** -----------------------------
 * Scoring genérico por lista de precios
 * (edge vs mediana + diversidad + tamaño muestra)
 * ----------------------------*/
function score_generic(arr = []) {
  const prices = (arr||[]).map(x=>Number(x && x.price)).filter(v=>v>0).sort((a,b)=>a-b);
  if (!prices.length) return 0;
  const mid  = (prices.length%2)
    ? prices[(prices.length-1)/2]
    : 0.5*(prices[prices.length/2-1] + prices[prices.length/2]);
  const best = prices[prices.length-1];
  if (!mid || !best) return 0;

  const raw  = (best/mid) - 1;                     // edge
  const bc   = Math.min(booksCount(arr), 4)/4;     // 0..1
  const n    = Math.min(arr.length, 6)/6;          // 0..1
  const edge = Math.min(Math.max(raw, 0), 0.25);   // cap 25%

  // mezcla: 60% edge, 25% diversidad, 15% tamaño de muestra
  return 0.60*edge + 0.25*bc + 0.15*n;
}

/** -----------------------------
 * Scores por mercado (canónicos)
 * Nota: si no hay datos, devuelven 0, así no rompen 1x2-only.
 * ----------------------------*/
function score1x2_v2(markets={}) { return score_generic(markets['1x2'] || []); }
function score_btts_v1(markets={}){ return score_generic(markets['btts'] || []); }
function score_ou25_v1(markets={}){ return score_generic(markets['ou_2_5'] || []); }
function score_dnb_v1(markets={}) { return score_generic(markets['dnb'] || []); }

/** -----------------------------
 * Score total con pesos (env-configurable)
 * ----------------------------*/
function totalScore(markets={}, W) {
  const s1x2  = score1x2_v2(markets||{});
  const sbtts = score_btts_v1(markets||{});
  const sou   = score_ou25_v1(markets||{});
  const sdnb  = score_dnb_v1(markets||{});
  const score = (W.w1*s1x2) + (W.w2*sbtts) + (W.w3*sou) + (W.w4*sdnb);
  return { score, s1x2, sbtts, sou, sdnb };
}

/** -----------------------------
 * Handler batch
 * ----------------------------*/
exports.handler = async (event) => {
  let body = {};
  try { body = event?.body ? JSON.parse(event.body) : {}; } catch(_){ body = {}; }

  const list    = Array.isArray(body.events) ? body.events : [];
  const limit   = Math.max(1, Math.min(Number(body.limit || 50), 200));
  const sleepMs = Number(process.env.BATCH_SLEEP_MS || 0);

  // filtros de presencia
  const min_h2x_len      = Math.max(0, Number(body.min_h2x_len ?? 2));
  const require_markets  = Array.isArray(body.require_markets) ? body.require_markets : [];

  // pesos multi-mercado (ENV → Body override opcional)
  const W = {
    w1: Number(body.weight_1x2  ?? process.env.WEIGHT_1X2  ?? 0.6),
    w2: Number(body.weight_btts ?? process.env.WEIGHT_BTTS ?? 0.2),
    w3: Number(body.weight_ou   ?? process.env.WEIGHT_OU   ?? 0.15),
    w4: Number(body.weight_dnb  ?? process.env.WEIGHT_DNB  ?? 0.05),
  };

  const results = [];
  const skipped = [];

  for (const evt of list) {
    
    const needBooks = Number(body.min_books_1x2 ?? process.env.RANK_MIN_BOOKS_1X2 ?? 1);
try {
      // payload base (one shot)
      let payload = await oneShotPayload({
        evt,
        match: null,
        fixture: { kickoff: evt?.commence || null, league_name: evt?.league || null }
      }) || {};
      payload.meta    = (payload.meta && typeof payload.meta === 'object') ? payload.meta : {};
      payload.markets = (payload.markets && typeof payload.markets === 'object') ? payload.markets : {};

      const before = Object.keys(payload?.markets||{}).length;

      // Enrich seguros (OddsAPI)
      payload = await ensureMarketsWithOddsAPI(payload, evt || {});
      const after  = Object.keys(payload?.markets||{}).length;

      // h2x_len y presencia de mercados
      const h2xArr = Array.isArray(payload.markets?.['1x2']) ? payload.markets['1x2'] : [];
      const h2xLen = h2xArr.length;
      const books1x2 = new Set(h2xArr.map(x=>x && (x.bookmaker||x.source)).filter(Boolean)).size;

      const books1x2 = new Set(h2xArr.map(x=>x && (x.bookmaker||x.source)).filter(Boolean)).size;


      // Meta
      payload.meta.enrich_info   = Object.assign({ before, after, source:'oddsapi:ensure' }, payload.meta?.enrich_info || {});
      payload.meta.enrich_status = (after > 0 ? 'ok' : 'error');

      (// Filtros por casas
      if (needBooks>0 && books1x2 < needBooks) {
        skipped.push({ evt, reason: `min_books_1x2<`, h2x_len: h2xLen, books_1x2: books1x2 });
        if (sleepMs > 0) await new Promise(r => setTimeout(r, sleepMs));
        continue;
      }

      // Filtros básicos (rápidos)
      if (min_h2x_len > 0 && h2xLen < min_h2x_len) {
        skipped.push({ evt, reason: `h2x_len<${min_h2x_len}`, h2x_len: h2xLen, markets_keys: Object.keys(payload.markets||{}) });
        if (sleepMs > 0) await new Promise(r => setTimeout(r, sleepMs));
        continue;
      }
      if (require_markets.length && !require_markets.every(mk => {
        const v = payload.markets?.[mk];
        return Array.isArray(v) ? v.length>0 : !!v;
      })) {
        skipped.push({ evt, reason: `missing required markets: ${require_markets.join(',')}`, markets_keys: Object.keys(payload.markets||{}) });
        if (sleepMs > 0) await new Promise(r => setTimeout(r, sleepMs));
        continue;
      }

      // Score compuesto
      const { score, s1x2, sbtts, sou, sdnb } = totalScore(payload.markets||{}, W);

      results.push({
        evt,
        score,
        score_1x2:  s1x2,
        score_btts: sbtts,
        score_ou25: sou,
        score_dnb:  sdnb,
        market_samples: marketSamples(payload.markets || {}),
        has_markets: Object.keys(payload.markets||{}),
        h2x_len: h2xLen,
        payload_meta: payload.meta || {}
      });

      if (sleepMs > 0) await new Promise(r => setTimeout(r, sleepMs));
    } catch (e) {
      results.push({ evt, score: 0, error: String(e?.message || e) });
    }
  }

  // Ordenar y truncar
  const ranked = results
    .filter(r => !r.skipped)
    .sort((a,b) => (b.score - a.score));

  const kept  = ranked.slice(0, limit);
  const rest  = skipped.concat(results.filter(r => r.skipped));

  return {
    statusCode: 200,
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({
      ok: true,
      count_in: list.length,
      count_ranked: ranked.length,
      count_skipped: rest.length,
      results: kept,
      skipped: rest.slice(0, 100) // por si acaso
    })
  };
};
